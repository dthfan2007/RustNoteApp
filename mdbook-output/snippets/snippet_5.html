<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Snippet 5 - Rust Notes App</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Notes App</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="snippet-5-authenticating-the-user"><a class="header" href="#snippet-5-authenticating-the-user">Snippet 5: Authenticating the user</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn start_authentication(
    &amp;mut self,
    username: String,
    password: String,
    is_registration: bool,
) {
    if self.is_authenticating {
        return; // Already authenticating
    }

    self.is_authenticating = true;
    self.authentication_error = None;
    self.auth_start_time = Some(std::time::Instant::now());

    let (sender, receiver) = mpsc::channel();
    self.auth_receiver = Some(receiver);

    let user_manager = self.user_manager.clone();

    // Spawn background thread for authentication
    thread::spawn(move || {
        println!("Starting authentication in background thread...");

        if let Some(mut user_manager) = user_manager {
            let result = if is_registration {
                // Registration flow
                match user_manager.create_user(username.clone(), &amp;password) {
                    Ok(_) =&gt; {
                        println!("User created successfully, now authenticating...");
                        // After successful registration, authenticate the user
                        match user_manager.authenticate(&amp;username, &amp;password) {
                            Ok(user) =&gt; {
                                let mut crypto_manager = CryptoManager::new();
                                match crypto_manager.initialize_for_user(&amp;user.id, &amp;password) {
                                    Ok(_) =&gt; {
                                        println!("Registration and authentication successful!");
                                        AuthResult::Success(crypto_manager, user)
                                    }
                                    Err(e) =&gt; {
                                        println!("Crypto initialization failed: {}", e);
                                        AuthResult::Error(format!(
                                            "Crypto initialization failed: {}",
                                            e
                                        ))
                                    }
                                }
                            }
                            Err(e) =&gt; {
                                println!("Authentication after registration failed: {}", e);
                                AuthResult::Error(format!(
                                    "Authentication after registration failed: {}",
                                    e
                                ))
                            }
                        }
                    }
                    Err(e) =&gt; {
                        println!("Registration failed: {}", e);
                        AuthResult::Error(format!("Registration failed: {}", e))
                    }
                }
            } else {
                // Login flow
                match user_manager.authenticate(&amp;username, &amp;password) {
                    Ok(user) =&gt; {
                        println!("User authenticated, initializing crypto...");
                        let mut crypto_manager = CryptoManager::new();
                        match crypto_manager.initialize_for_user(&amp;user.id, &amp;password) {
                            Ok(_) =&gt; {
                                println!("Login successful!");
                                AuthResult::Success(crypto_manager, user)
                            }
                            Err(e) =&gt; {
                                println!("Crypto initialization failed: {}", e);
                                AuthResult::Error(format!("Authentication failed: {}", e))
                            }
                        }
                    }
                    Err(e) =&gt; {
                        println!("Login failed: {}", e);
                        AuthResult::Error(format!("Login failed: {}", e))
                    }
                }
            };

            if let Err(_) = sender.send(result) {
                println!("Failed to send authentication result - UI may have closed");
            }
        } else {
            let _ = sender.send(AuthResult::Error("User manager not available".to_string()));
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="comprehensive-asynchronous-authentication-system-with-background-processing"><a class="header" href="#comprehensive-asynchronous-authentication-system-with-background-processing">Comprehensive Asynchronous Authentication System with Background Processing</a></h2>
<p>This sophisticated authentication function represents a critical component of the application's security infrastructure, implementing a robust, non-blocking authentication system that handles both user registration and login workflows. The function demonstrates advanced concurrent programming techniques while maintaining security best practices and providing excellent user experience through background processing.</p>
<h3 id="detailed-authentication-architecture-analysis"><a class="header" href="#detailed-authentication-architecture-analysis">Detailed Authentication Architecture Analysis</a></h3>
<p><strong>Function Signature and State Management:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn start_authentication(&amp;mut self, username: String, password: String, is_registration: bool)
<span class="boring">}</span></code></pre></pre>
<p>This function serves as the primary entry point for all authentication operations, accepting:</p>
<ul>
<li><strong>Username</strong>: Owned String to avoid lifetime complications in the background thread</li>
<li><strong>Password</strong>: String slice that will be moved into the background thread</li>
<li><strong>Registration Flag</strong>: Boolean that determines whether to create a new account or authenticate existing credentials</li>
</ul>
<p><strong>Concurrency Control and State Protection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.is_authenticating {
    return; // Already authenticating
}
self.is_authenticating = true;
<span class="boring">}</span></code></pre></pre>
<p>The function implements critical concurrency control mechanisms:</p>
<ul>
<li><strong>Mutual Exclusion</strong>: Prevents multiple simultaneous authentication attempts that could cause race conditions</li>
<li><strong>State Protection</strong>: Ensures the authentication system remains in a consistent state</li>
<li><strong>Resource Management</strong>: Prevents resource exhaustion from multiple concurrent authentication threads</li>
<li><strong>User Experience</strong>: Provides clear feedback about ongoing authentication processes</li>
</ul>
<p><strong>Error State Management:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.authentication_error = None;
self.auth_start_time = Some(std::time::Instant::now());
<span class="boring">}</span></code></pre></pre>
<p>The system carefully manages authentication state:</p>
<ul>
<li><strong>Error Clearing</strong>: Resets any previous authentication errors to provide clean state</li>
<li><strong>Timing Tracking</strong>: Records authentication start time for performance monitoring and timeout handling</li>
<li><strong>State Consistency</strong>: Ensures each authentication attempt starts with a clean slate</li>
</ul>
<p><strong>Inter-Thread Communication Setup:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sender, receiver) = mpsc::channel();
self.auth_receiver = Some(receiver);
<span class="boring">}</span></code></pre></pre>
<p>This establishes a robust communication channel between threads:</p>
<ul>
<li><strong>Message Passing</strong>: Uses Rust's safe message passing instead of shared memory</li>
<li><strong>Thread Safety</strong>: Eliminates data races and memory safety issues</li>
<li><strong>Asynchronous Communication</strong>: Allows the UI thread to remain responsive while authentication proceeds</li>
<li><strong>Result Delivery</strong>: Provides a reliable mechanism for delivering authentication results</li>
</ul>
<p><strong>Resource Cloning for Thread Safety:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_manager = self.user_manager.clone();
<span class="boring">}</span></code></pre></pre>
<p>The system carefully manages shared resources:</p>
<ul>
<li><strong>Arc/Rc Cloning</strong>: Clones the reference-counted user manager for thread safety</li>
<li><strong>Ownership Transfer</strong>: Moves necessary resources into the background thread</li>
<li><strong>Memory Safety</strong>: Ensures no dangling pointers or use-after-free issues</li>
<li><strong>Resource Sharing</strong>: Allows multiple threads to safely access the user management system</li>
</ul>
<p><strong>Background Thread Spawning:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread::spawn(move || {
    println!("Starting authentication in background thread...");
<span class="boring">}</span></code></pre></pre>
<p>The background processing system provides several critical benefits:</p>
<ul>
<li><strong>Non-Blocking UI</strong>: Keeps the user interface responsive during potentially slow authentication operations</li>
<li><strong>Scalability</strong>: Can handle multiple users without blocking the main application</li>
<li><strong>Error Isolation</strong>: Authentication failures don't crash the main application thread</li>
<li><strong>Performance</strong>: Allows CPU-intensive operations like password hashing to run without affecting UI responsiveness</li>
</ul>
<p><strong>Registration Workflow Implementation:</strong>
The registration process follows a comprehensive multi-step approach:</p>
<p><strong>User Account Creation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match user_manager.create_user(username.clone(), &amp;password) {
    Ok(_) =&gt; {
        println!("User created successfully, now authenticating...");
<span class="boring">}</span></code></pre></pre>
<p>The registration process includes:</p>
<ul>
<li><strong>Account Validation</strong>: Comprehensive validation of username and password requirements</li>
<li><strong>Duplicate Prevention</strong>: Ensures usernames are unique across the system</li>
<li><strong>Secure Storage</strong>: Stores user credentials using cryptographically secure methods</li>
<li><strong>Atomic Operations</strong>: Ensures account creation is all-or-nothing to prevent partial states</li>
</ul>
<p><strong>Post-Registration Authentication:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match user_manager.authenticate(&amp;username, &amp;password) {
    Ok(user) =&gt; {
        let mut crypto_manager = CryptoManager::new();
        match crypto_manager.initialize_for_user(&amp;user.id, &amp;password) {
<span class="boring">}</span></code></pre></pre>
<p>After successful registration, the system immediately authenticates the new user:</p>
<ul>
<li><strong>Seamless Experience</strong>: Users don't need to log in separately after registration</li>
<li><strong>Consistency</strong>: Uses the same authentication path as regular login</li>
<li><strong>Security Validation</strong>: Ensures the newly created account works correctly</li>
<li><strong>Crypto Initialization</strong>: Sets up the user's encryption environment immediately</li>
</ul>
<p><strong>Login Workflow Implementation:</strong>
The login process focuses on credential verification and system initialization:</p>
<p><strong>Credential Verification:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match user_manager.authenticate(&amp;username, &amp;password) {
    Ok(user) =&gt; {
        println!("User authenticated, initializing crypto...");
<span class="boring">}</span></code></pre></pre>
<p>The login authentication includes:</p>
<ul>
<li><strong>Password Verification</strong>: Uses secure password hashing algorithms for verification</li>
<li><strong>Account Status Checking</strong>: Ensures the account is active and not locked</li>
<li><strong>Audit Logging</strong>: Records authentication attempts for security monitoring</li>
<li><strong>User Data Retrieval</strong>: Loads user profile information for the session</li>
</ul>
<p><strong>Cryptographic System Initialization:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut crypto_manager = CryptoManager::new();
match crypto_manager.initialize_for_user(&amp;user.id, &amp;password) {
    Ok(_) =&gt; {
        println!("Login successful!");
        AuthResult::Success(crypto_manager, user)
    }
<span class="boring">}</span></code></pre></pre>
<p>The crypto initialization process:</p>
<ul>
<li><strong>Key Derivation</strong>: Generates user-specific encryption keys from the password</li>
<li><strong>Hardware Binding</strong>: Validates hardware fingerprints for additional security</li>
<li><strong>Vault Access</strong>: Unlocks the user's encrypted data vault</li>
<li><strong>Security Metadata</strong>: Loads and validates security configuration</li>
</ul>
<p><strong>Comprehensive Error Handling:</strong>
The system implements detailed error handling for all failure scenarios:</p>
<p><strong>Registration Errors:</strong></p>
<ul>
<li><strong>Account Creation Failures</strong>: Handles username conflicts, validation errors, and storage issues</li>
<li><strong>Authentication Failures</strong>: Manages cases where newly created accounts can't be authenticated</li>
<li><strong>Crypto Initialization Errors</strong>: Handles encryption system setup failures</li>
</ul>
<p><strong>Login Errors:</strong></p>
<ul>
<li><strong>Invalid Credentials</strong>: Provides secure error messages that don't leak information</li>
<li><strong>Account Lockouts</strong>: Handles temporarily or permanently disabled accounts</li>
<li><strong>System Errors</strong>: Manages database connectivity and other infrastructure issues</li>
</ul>
<p><strong>Communication Error Handling:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Err(_) = sender.send(result) {
    println!("Failed to send authentication result - UI may have closed");
}
<span class="boring">}</span></code></pre></pre>
<p>The system gracefully handles communication failures:</p>
<ul>
<li><strong>Channel Closure Detection</strong>: Recognizes when the UI thread has terminated</li>
<li><strong>Resource Cleanup</strong>: Prevents resource leaks when communication fails</li>
<li><strong>Graceful Degradation</strong>: Continues operating even if result delivery fails</li>
<li><strong>Logging</strong>: Records communication failures for debugging purposes</li>
</ul>
<p><strong>Thread Safety and Resource Management:</strong>
The entire authentication system is designed with thread safety in mind:</p>
<ul>
<li><strong>No Shared Mutable State</strong>: Uses message passing instead of shared memory</li>
<li><strong>Resource Ownership</strong>: Clear ownership transfer prevents data races</li>
<li><strong>Error Propagation</strong>: Safe error handling across thread boundaries</li>
<li><strong>Memory Management</strong>: Automatic cleanup when threads complete</li>
</ul>
<p><strong>Security Considerations:</strong>
The authentication system implements several security best practices:</p>
<ul>
<li><strong>Timing Attack Resistance</strong>: Consistent timing regardless of failure type</li>
<li><strong>Information Leakage Prevention</strong>: Generic error messages prevent username enumeration</li>
<li><strong>Secure Logging</strong>: Logs security events without exposing sensitive data</li>
<li><strong>Resource Exhaustion Protection</strong>: Limits concurrent authentication attempts</li>
</ul>
<p><strong>Performance Optimization:</strong>
The system is optimized for both security and performance:</p>
<ul>
<li><strong>Background Processing</strong>: Keeps UI responsive during slow operations</li>
<li><strong>Efficient Resource Usage</strong>: Minimizes memory allocation and CPU usage</li>
<li><strong>Caching</strong>: Reuses expensive computations where safe to do so</li>
<li><strong>Monitoring</strong>: Tracks performance metrics for optimization opportunities</li>
</ul>
<p>This snippet handles the complete user authentication process in a background thread to prevent UI blocking. The <code>start_authentication()</code> function:</p>
<p><strong>Authentication Management</strong>:</p>
<ul>
<li><strong>Prevents duplicate operations</strong>: Checks if authentication is already in progress</li>
<li><strong>Background processing</strong>: Uses separate thread to avoid freezing the user interface</li>
<li><strong>Result communication</strong>: Uses message passing (mpsc channel) to send results back to UI</li>
</ul>
<p><strong>Dual Authentication Flows</strong>:</p>
<p><strong>Registration Process</strong>:</p>
<ul>
<li><strong>Creates new user account</strong>: Validates and stores user credentials securely</li>
<li><strong>Automatic login</strong>: Immediately authenticates the newly created user</li>
<li><strong>Crypto initialization</strong>: Sets up encryption system for the new user account</li>
</ul>
<p><strong>Login Process</strong>:</p>
<ul>
<li><strong>Credential verification</strong>: Validates username and password against stored data</li>
<li><strong>Crypto system setup</strong>: Initializes user-specific encryption using their password</li>
</ul>
<p><strong>Error Handling</strong>:</p>
<ul>
<li><strong>Comprehensive error reporting</strong>: Provides detailed feedback for various failure scenarios</li>
<li><strong>Graceful degradation</strong>: Handles cases where UI components may have closed during authentication</li>
<li><strong>Logging</strong>: Provides detailed console output for debugging authentication issues</li>
</ul>
<p>This function is crucial for maintaining application responsiveness while performing potentially time-consuming cryptographic operations.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../snippets/snippet_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../snippets/snippet_6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../snippets/snippet_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../snippets/snippet_6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
