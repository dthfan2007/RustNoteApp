<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Snippet 4 - Rust Notes App</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Notes App</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="snippet-4-create-user-locked-vault"><a class="header" href="#snippet-4-create-user-locked-vault">Snippet 4: Create User Locked Vault</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn initialize_for_user(&amp;mut self, user_id: &amp;str, password: &amp;str) -&gt; Result&lt;()&gt; {
    println!("Starting crypto initialization for user: {}", user_id);
    let start_time = std::time::Instant::now();

    // Create user-specific config directory
    let mut user_config_path = self.config_path.clone();
    user_config_path.push("users");
    user_config_path.push(user_id);

    if !user_config_path.exists() {
        fs::create_dir_all(&amp;user_config_path)?;
    }

    let key_file = user_config_path.join("auth.hash");
    let metadata_file = user_config_path.join("security.meta");

    let key = if key_file.exists() &amp;&amp; metadata_file.exists() {
        println!("Loading existing user configuration...");

        // Load existing setup
        let stored_hash = fs::read_to_string(&amp;key_file)?;
        let parsed_hash = PasswordHash::new(&amp;stored_hash)
            .map_err(|e| anyhow!("Failed to parse password hash: {}", e))?;

        println!("Verifying password...");
        // Verify password (this should be fast with default Argon2)
        Argon2::default()
            .verify_password(password.as_bytes(), &amp;parsed_hash)
            .map_err(|e| anyhow!("Password verification failed: {}", e))?;

        println!("Loading metadata...");
        // Load metadata
        let metadata_content = fs::read_to_string(&amp;metadata_file)?;
        let mut metadata: SecurityMetadata = serde_json::from_str(&amp;metadata_content)
            .map_err(|e| anyhow!("Failed to parse security metadata: {}", e))?;

        // Handle backward compatibility - if hardware_components is empty, regenerate it
        if metadata.hardware_components.is_empty() {
            println!("Upgrading old metadata format...");
            let (current_hash, current_components) =
                self.generate_stable_hardware_fingerprint()?;

            // Update the metadata with current components
            metadata.hardware_components = current_components;
            metadata.hardware_fingerprint_hash = current_hash;

            // Save updated metadata
            fs::write(&amp;metadata_file, serde_json::to_string_pretty(&amp;metadata)?)?;
            println!("Metadata upgraded successfully");
        } else {
            println!("Checking hardware fingerprint...");
            // Get current hardware components
            let (current_hash, current_components) =
                self.generate_stable_hardware_fingerprint()?;

            // Check if hardware fingerprint matches
            if metadata.hardware_fingerprint_hash != current_hash {
                // Try to identify what changed
                let mut changed_components = Vec::new();
                for (i, (stored, current)) in metadata
                    .hardware_components
                    .iter()
                    .zip(current_components.iter())
                    .enumerate()
                {
                    if stored != current {
                        changed_components
                            .push(format!("Component {}: '{}' -&gt; '{}'", i, stored, current));
                    }
                }

                if !changed_components.is_empty() {
                    println!("Hardware changes detected:");
                    for change in &amp;changed_components {
                        println!("  {}", change);
                    }

                    // For now, let's be more lenient and only fail if critical components changed
                    if self.is_critical_hardware_change(
                        &amp;metadata.hardware_components,
                        &amp;current_components,
                    ) {
                        return Err(anyhow!(
                            "Critical hardware components changed: {}",
                            changed_components.join(", ")
                        ));
                    } else {
                        println!("Non-critical hardware changes detected, allowing access...");
                        // Update the stored fingerprint
                        metadata.hardware_fingerprint_hash = current_hash;
                        metadata.hardware_components = current_components;

                        // Save updated metadata
                        fs::write(&amp;metadata_file, serde_json::to_string_pretty(&amp;metadata)?)?;
                    }
                }
            } else {
                println!("Hardware fingerprint matches!");
            }
        }

        self.security_metadata = Some(metadata);

        println!("Deriving encryption key...");
        // Use standard security key derivation
        self.derive_secure_key(password)
    } else {
        println!("First time setup for user...");

        let current_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let (hardware_hash, hardware_components) =
            self.generate_stable_hardware_fingerprint()?;

        println!("Initial hardware components: {:?}", hardware_components);
        println!("Initial hardware hash: {}", hardware_hash);

        let metadata = SecurityMetadata {
            version: 1,
            created_timestamp: current_time,
            hardware_fingerprint_hash: hardware_hash,
            hardware_components,
        };

        let key = self.derive_secure_key(password);

        println!("Storing password hash...");
        // Store password hash
        let verification_salt = SaltString::generate(&amp;mut OsRng);
        let argon2 = Argon2::default();
        let password_hash = argon2
            .hash_password(password.as_bytes(), &amp;verification_salt)
            .map_err(|e| anyhow!("Failed to hash password: {}", e))?;

        fs::write(&amp;key_file, password_hash.to_string())?;
        fs::write(&amp;metadata_file, serde_json::to_string_pretty(&amp;metadata)?)?;

        self.secure_file_permissions(&amp;key_file)?;
        self.secure_file_permissions(&amp;metadata_file)?;

        self.security_metadata = Some(metadata);
        key
    };

    self.cipher = Some(ChaCha20Poly1305::new(&amp;key));

    let elapsed = start_time.elapsed();
    println!(
        "Crypto initialization completed in {:.2}s",
        elapsed.as_secs_f64()
    );

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-cryptographic-user-vault-system-with-hardware-binding"><a class="header" href="#advanced-cryptographic-user-vault-system-with-hardware-binding">Advanced Cryptographic User Vault System with Hardware Binding</a></h2>
<p>This sophisticated function represents the heart of the application's security architecture, implementing a comprehensive user-specific cryptographic vault system. It combines multiple layers of security including password-based authentication, hardware fingerprinting, and modern encryption algorithms to create a robust, tamper-resistant storage system.</p>
<h3 id="comprehensive-security-architecture-analysis"><a class="header" href="#comprehensive-security-architecture-analysis">Comprehensive Security Architecture Analysis</a></h3>
<p><strong>Function Signature and Purpose:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn initialize_for_user(&amp;mut self, user_id: &amp;str, password: &amp;str) -&gt; Result&lt;()&gt;
<span class="boring">}</span></code></pre></pre>
<p>This function serves as the central security initialization point, responsible for establishing or restoring a user's complete cryptographic environment. It handles both first-time user setup and subsequent authentication sessions with equal security rigor.</p>
<p><strong>Performance Monitoring and Logging:</strong>
The function begins with comprehensive logging and performance tracking:</p>
<ul>
<li><strong>Detailed Logging</strong>: Provides extensive debug information for security auditing and troubleshooting</li>
<li><strong>Performance Timing</strong>: Tracks initialization duration to identify potential performance issues or security attacks</li>
<li><strong>User Context</strong>: Logs the specific user ID for audit trail purposes</li>
</ul>
<p><strong>User-Specific Directory Architecture:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut user_config_path = self.config_path.clone();
user_config_path.push("users");
user_config_path.push(user_id);
<span class="boring">}</span></code></pre></pre>
<p>The system creates a hierarchical directory structure that provides:</p>
<ul>
<li><strong>User Isolation</strong>: Each user has completely separate storage, preventing data leakage between accounts</li>
<li><strong>Organized Storage</strong>: Clear directory structure makes system administration and backup easier</li>
<li><strong>Scalability</strong>: Can handle unlimited users without naming conflicts or performance degradation</li>
<li><strong>Security Boundaries</strong>: File system permissions can be applied at the user level</li>
</ul>
<p><strong>Critical Security Files Management:</strong>
Two essential files store the user's security credentials:</p>
<ul>
<li><strong><code>auth.hash</code></strong>: Contains the Argon2 password hash for authentication</li>
<li><strong><code>security.meta</code></strong>: Stores hardware fingerprinting data and security metadata</li>
</ul>
<p><strong>Existing User Authentication Flow:</strong>
For returning users, the system performs a multi-step verification process:</p>
<p><strong>Password Hash Verification:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stored_hash = fs::read_to_string(&amp;key_file)?;
let parsed_hash = PasswordHash::new(&amp;stored_hash)?;
Argon2::default().verify_password(password.as_bytes(), &amp;parsed_hash)?;
<span class="boring">}</span></code></pre></pre>
<p>This implements industry-standard password verification:</p>
<ul>
<li><strong>Argon2 Algorithm</strong>: Uses the winner of the Password Hashing Competition, resistant to both GPU and ASIC attacks</li>
<li><strong>Salt Integration</strong>: Each password hash includes a unique salt to prevent rainbow table attacks</li>
<li><strong>Constant-Time Verification</strong>: Prevents timing attacks that could leak password information</li>
<li><strong>Memory-Hard Function</strong>: Requires significant memory allocation, making brute force attacks expensive</li>
</ul>
<p><strong>Hardware Fingerprinting System:</strong>
The system implements sophisticated hardware binding to prevent credential theft:</p>
<p><strong>Backward Compatibility Handling:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if metadata.hardware_components.is_empty() {
    println!("Upgrading old metadata format...");
    let (current_hash, current_components) = self.generate_stable_hardware_fingerprint()?;
    metadata.hardware_components = current_components;
    metadata.hardware_fingerprint_hash = current_hash;
}
<span class="boring">}</span></code></pre></pre>
<p>This graceful upgrade system:</p>
<ul>
<li><strong>Seamless Migration</strong>: Automatically upgrades older installations without user intervention</li>
<li><strong>Data Preservation</strong>: Maintains existing user data while adding new security features</li>
<li><strong>Future-Proofing</strong>: Establishes a pattern for future security enhancements</li>
</ul>
<p><strong>Hardware Change Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if metadata.hardware_fingerprint_hash != current_hash {
    let mut changed_components = Vec::new();
    for (i, (stored, current)) in metadata.hardware_components.iter().zip(current_components.iter()).enumerate() {
        if stored != current {
            changed_components.push(format!("Component {}: '{}' -&gt; '{}'", i, stored, current));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The system provides intelligent hardware change handling:</p>
<ul>
<li><strong>Component-Level Analysis</strong>: Identifies exactly which hardware components have changed</li>
<li><strong>Detailed Logging</strong>: Records specific changes for security auditing</li>
<li><strong>Flexible Response</strong>: Distinguishes between critical and non-critical hardware changes</li>
<li><strong>User Transparency</strong>: Provides clear information about detected changes</li>
</ul>
<p><strong>Critical vs Non-Critical Hardware Changes:</strong>
The system implements a nuanced approach to hardware changes:</p>
<ul>
<li><strong>Critical Changes</strong>: Major components like CPU or motherboard that indicate potential system compromise</li>
<li><strong>Non-Critical Changes</strong>: Minor changes like RAM upgrades or peripheral additions</li>
<li><strong>Adaptive Security</strong>: Updates fingerprints for non-critical changes while blocking critical ones</li>
</ul>
<p><strong>First-Time User Setup:</strong>
For new users, the system performs comprehensive initialization:</p>
<p><strong>Security Metadata Creation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let metadata = SecurityMetadata {
    version: 1,
    created_timestamp: current_time,
    hardware_fingerprint_hash: hardware_hash,
    hardware_components,
};
<span class="boring">}</span></code></pre></pre>
<p>This metadata provides:</p>
<ul>
<li><strong>Version Tracking</strong>: Enables future security upgrades and compatibility handling</li>
<li><strong>Timestamp Recording</strong>: Creates audit trail for account creation</li>
<li><strong>Hardware Binding</strong>: Establishes the baseline hardware configuration</li>
<li><strong>Component Inventory</strong>: Detailed record of hardware components for change detection</li>
</ul>
<p><strong>Secure Key Derivation:</strong>
The system uses the <code>derive_secure_key()</code> method to generate encryption keys:</p>
<ul>
<li><strong>Password-Based Key Derivation</strong>: Uses the user's password as the primary key material</li>
<li><strong>Cryptographically Secure</strong>: Employs proven key derivation functions</li>
<li><strong>Unique Per User</strong>: Each user gets completely unique encryption keys</li>
<li><strong>Memory Protection</strong>: Keys are handled securely in memory</li>
</ul>
<p><strong>Password Hash Storage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verification_salt = SaltString::generate(&amp;mut OsRng);
let argon2 = Argon2::default();
let password_hash = argon2.hash_password(password.as_bytes(), &amp;verification_salt)?;
<span class="boring">}</span></code></pre></pre>
<p>The password storage system implements best practices:</p>
<ul>
<li><strong>Cryptographically Secure Random Salt</strong>: Uses OS-provided randomness for salt generation</li>
<li><strong>Argon2 Default Parameters</strong>: Uses recommended parameters for security vs performance balance</li>
<li><strong>Secure Storage</strong>: Hash is immediately written to disk with secure permissions</li>
</ul>
<p><strong>File System Security:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.secure_file_permissions(&amp;key_file)?;
self.secure_file_permissions(&amp;metadata_file)?;
<span class="boring">}</span></code></pre></pre>
<p>The system applies strict file permissions:</p>
<ul>
<li><strong>Owner-Only Access</strong>: Files are readable and writable only by the file owner</li>
<li><strong>No Group/Other Access</strong>: Prevents other users on the system from accessing sensitive data</li>
<li><strong>Cross-Platform Implementation</strong>: Handles permission setting across different operating systems</li>
</ul>
<p><strong>Cipher Initialization:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.cipher = Some(ChaCha20Poly1305::new(&amp;key));
<span class="boring">}</span></code></pre></pre>
<p>The final step establishes the encryption system:</p>
<ul>
<li><strong>ChaCha20Poly1305</strong>: Modern authenticated encryption algorithm</li>
<li><strong>Key Binding</strong>: Cipher is initialized with the user-specific derived key</li>
<li><strong>Ready State</strong>: System is now ready for encrypt/decrypt operations</li>
</ul>
<p><strong>Performance Optimization:</strong>
The function concludes with performance reporting:</p>
<ul>
<li><strong>Timing Analysis</strong>: Measures and reports total initialization time</li>
<li><strong>Performance Monitoring</strong>: Helps identify potential security attacks or system issues</li>
<li><strong>User Feedback</strong>: Provides transparency about system operations</li>
</ul>
<p><strong>Error Handling and Security:</strong>
Throughout the function, comprehensive error handling ensures:</p>
<ul>
<li><strong>Graceful Failure</strong>: All errors are properly propagated with descriptive messages</li>
<li><strong>Security Logging</strong>: Failed operations are logged for security monitoring</li>
<li><strong>State Consistency</strong>: Partial failures don't leave the system in an inconsistent state</li>
<li><strong>Attack Resistance</strong>: Error messages don't leak sensitive information</li>
</ul>
<p>This snippet implements the core cryptographic initialization system for user-specific encrypted storage. The <code>initialize_for_user()</code> function:</p>
<p><strong>Security Setup</strong>:</p>
<ul>
<li><strong>Creates user-specific directories</strong>: Establishes isolated storage for each user</li>
<li><strong>Manages encryption keys</strong>: Derives secure keys from user passwords using Argon2</li>
<li><strong>Hardware fingerprinting</strong>: Binds encryption to specific hardware to prevent unauthorized access</li>
</ul>
<p><strong>Key Operations</strong>:</p>
<ul>
<li><strong>First-time setup</strong>: Generates new encryption keys and stores security metadata</li>
<li><strong>Existing user login</strong>: Verifies password and loads existing encryption configuration</li>
<li><strong>Hardware change detection</strong>: Identifies and handles hardware modifications gracefully</li>
<li><strong>Backward compatibility</strong>: Upgrades old metadata formats automatically</li>
</ul>
<p><strong>Security Features</strong>:</p>
<ul>
<li><strong>Password verification</strong>: Uses cryptographically secure Argon2 hashing</li>
<li><strong>File permissions</strong>: Sets restrictive permissions on sensitive files (Unix systems)</li>
<li><strong>ChaCha20Poly1305 encryption</strong>: Initializes modern, secure cipher for data protection</li>
</ul>
<p>This is the foundation of the application's security model, ensuring each user's data remains encrypted and tied to their specific device.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../snippets/snippet_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../snippets/snippet_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../snippets/snippet_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../snippets/snippet_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
